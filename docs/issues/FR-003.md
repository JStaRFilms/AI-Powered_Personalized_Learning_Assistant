# [FR-003] Curriculum Material Uploads

## Labels
`MUS`, `enhancement`, `materials`, `upload`

## User Story
As a student, I want to upload PDFs and text notes so that the AI can learn from my specific course materials.

## Proposed Solution

### Overview
Implement an interface for uploading documents (`.pdf`, `.txt`, `.md`). Set up standard form data handling in Next.js Server Actions. Once the file is verified, pass the raw data to the background ingestion process defined in the RAG pipeline.

### Implementation Flow
1. Create a `FileUploader` client component utilizing standard HTML `<input type="file" />` with Tailwind styling.
2. Implement a Server Action (`uploadMaterial.ts`) to receive the `FormData`.
3. Validate the file type and size on the server.
4. If it's a PDF, use `pdf-parse` (or a similar reliable Node-compatible PDF library) to extract raw text.
5. Save the `Document` metadata to Prisma.
6. Trigger the RAG pipeline service to chunk and embed.

### Technical Approach

```typescript
// Proposed Server Action Architecture
'use server'

import { auth } from "@/lib/auth";
import prisma from "@/lib/prisma";
import pdf from "pdf-parse"; // Or a suitable alternative that runs on Neon/Vercel Node

export async function uploadMaterial(formData: FormData) {
  // 1. Auth check
  // 2. Extract file from FormData
  const file = formData.get("file") as File;
  
  // 3. Extract text
  let rawText = "";
  if (file.type === "application/pdf") {
    const arrayBuffer = await file.arrayBuffer();
    const data = await pdf(Buffer.from(arrayBuffer));
    rawText = data.text;
  } else if (file.type === "text/plain") {
    rawText = await file.text();
  } else {
    throw new Error("Unsupported file type");
  }

  // 4. Save to DB and trigger chunking (simulated here)
  const doc = await prisma.document.create({
    data: { title: file.name, content: rawText } // Add User relations as needed
  });

  // Call the RAG service (ideally async/background)
  // await processDocumentForRAG(doc.id, rawText);
  return { success: true, docId: doc.id };
}
```

### Key Considerations
- File size limits and validation on both client and server to prevent abuse.
- User feedback during the upload and parsing phase (loading states).
- Because complex PDFs can be tricky, the parser should be robust, stripping out non-text artifacts smoothly.

## Acceptance Criteria
- [ ] A user can select a `.pdf` or `.txt` file via a UI form.
- [ ] The file is correctly sent to the server and its text is extracted.
- [ ] A record is created in the `Document` table.
- [ ] Appropriate error handling is shown if the file type/size is invalid or parsing fails.
